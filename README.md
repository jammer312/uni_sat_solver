Программа парсит КНФ со stdin.
Не smtlib2, парсит только нужное для EUF.
Парсит нечто такое (на деле немного больше, но этого по идее должно хватить):
`КНФ` :=
	| `(КНФ)`
	| `ДИЗЪЮНКТЫ`

`ДИЗЪЮНКТЫ` :=
	| `ДИЗЪЮНКТ`
	| `ДИЗЪЮНКТ && ДИЗЪЮНКТЫ`

`ДИЗЪЮНКТ` :=
	| `(ДИЗЪЮНКТ)`
	| `АТОМЫ`

`АТОМЫ` :=
	| `АТОМ`
	| `АТОМЫ || АТОМЫ`

`АТОМ` :=
	| `ТЕРМ == ТЕРМ`
	| `ТЕРМ != ТЕРМ`

`ТЕРМ` :=
	| `ИДЕНТИФИКАТОР`
	| `ИДЕНТИФИКАТОР(АРГУМЕНТЫ)`

`АРГУМЕНТЫ` :=
	| `ИДЕНТИФИКАТОР`
	| `ИДЕНТИФИКАТОР, АРГУМЕНТЫ`

`ИДЕНТИФИКАТОР` := `[буква][буква или цифра]*`

Привычного приоритета операций нет, скобки не нужны (но с ними тоже должно парситься)

Солвер не верит в существование констант (любой идентификатор считает переменной). Если вдруг это таки нужно, достаточно топорный (но простой) способ добавить константы - пометить некоторые идентификаторы как константы (сделать еще один вариант в определении терма), и перед запуском солвера дополнять КНФ дизъюнктами вида `const1 != const2` (по идее при этом не нужно никаких дополнительных действий по замене идентификаторов обратно на константы, т.к. в EUF значения не важны, важно только равенство). Не делалось, ибо кажется, что в этой логике это не то что бы важно, при этом добавляет громоздкости.
Примеры входных данных есть в testcases/smt_euf/*
